{
  "language": "Solidity",
  "sources": {
    "contracts/TasmiaFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\nimport \"./TasmiaRequest.sol\";\r\n\r\npragma solidity ^0.8.15;\r\n\r\ncontract TasmiaFactory {\r\n    //Init the array of deployed contract addresses\r\n    address[] public deployedData;\r\n    mapping(address => address[]) public studentsData;\r\n\r\n    function createData(\r\n        string memory name,\r\n        string memory description,\r\n        string memory imageHash,\r\n        uint256 price,\r\n        string[] memory moduleNames,\r\n        string[] memory moduleDescriptions,\r\n        string[] memory materialHashes,\r\n        string[] memory questionHashes\r\n    ) public {\r\n        TasmiaRequest newData = new TasmiaRequest(\r\n            msg.sender,\r\n            name,\r\n            description,\r\n            imageHash,\r\n            price,\r\n            moduleNames,\r\n            moduleDescriptions,\r\n            materialHashes,\r\n            questionHashes\r\n        );\r\n        deployedData.push(address(newData));\r\n    }\r\n\r\n    function joinData(address DataAddress) public payable {\r\n        TasmiaRequest Data = TasmiaRequest(payable(DataAddress));\r\n        studentsData[msg.sender].push(DataAddress);\r\n        Data.enroll{value: msg.value}(msg.sender);\r\n    }\r\n\r\n    function returnEnrolledData() public view returns (address[] memory) {\r\n        address[] memory Data = studentsData[msg.sender];\r\n        return (Data);\r\n    }\r\n\r\n    function getDeployedData() public view returns (address[] memory) {\r\n        return deployedData;\r\n    }\r\n}\r\n"
    },
    "contracts/TasmiaRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.15;\r\n\r\ncontract TasmiaRequest {\r\n    struct Module {\r\n        string name;\r\n        string description;\r\n        string materialsHash;\r\n        string questionsHash;\r\n    }\r\n\r\n    struct Request {\r\n        string name;\r\n        string description;\r\n        address author;\r\n        bool confirmed;\r\n        uint256 tokens;\r\n        uint256 approvers;\r\n        uint256 baseVersion;\r\n    }\r\n\r\n    string public dataName;\r\n    string public dataDescription;\r\n    string public dataImageHash;\r\n    uint256 public index;\r\n    uint256 public requestIndex;\r\n    uint256 public dataPrice;\r\n    uint256 public numOfMaintainers;\r\n    uint256 public tokenPot;\r\n    address public author;\r\n    address public manager;\r\n    address public momAddress;\r\n    Request[] public listOfRequests;\r\n    Module[] public modulesToPush;\r\n    Module[] public currentModules;\r\n    mapping(address => uint256) public balance;\r\n    mapping(address => bool) public maintainers;\r\n    mapping(uint256 => Module[]) public requestModules;\r\n    mapping(uint256 => Module[]) public moduleVersions;\r\n    mapping(uint256 => mapping(address => bool)) public maintainerVotes;\r\n    mapping(address => uint256) public allowance;\r\n    mapping(address => bool) public enrolled;\r\n    mapping(uint256 => address) tokenHolders;\r\n    uint256 tokenHoldersCounter;\r\n\r\n    constructor(\r\n        address _manager,\r\n        string memory name,\r\n        string memory description,\r\n        string memory imageHash,\r\n        uint256 price,\r\n        string[] memory moduleNames,\r\n        string[] memory moduleDescriptions,\r\n        string[] memory materialHashes,\r\n        string[] memory questionHashes\r\n    ) {\r\n        manager = _manager;\r\n        tokenHoldersCounter = 1;\r\n        tokenHolders[0] = manager;\r\n        numOfMaintainers = 1;\r\n        balance[manager] = 500;\r\n        tokenPot = 500;\r\n        momAddress = msg.sender;\r\n        dataName = name;\r\n        dataDescription = description;\r\n        dataImageHash = imageHash;\r\n        dataPrice = price;\r\n        pushModules(moduleNames, moduleDescriptions, materialHashes, questionHashes);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    function getSummaryInformation()\r\n        external\r\n        view\r\n        returns (\r\n            string memory,\r\n            string memory,\r\n            string memory,\r\n            address\r\n        )\r\n    {\r\n        return (dataName, dataDescription, dataImageHash, manager);\r\n    }\r\n\r\n    function addMaintainer(address newMaintainer) external {\r\n        require(maintainers[newMaintainer] != true);\r\n\r\n        maintainers[newMaintainer] = true;\r\n        tokenHolders[tokenHoldersCounter] = newMaintainer;\r\n        numOfMaintainers++;\r\n        tokenHoldersCounter++;\r\n    }\r\n\r\n    function pushModules(\r\n        string[] memory _name,\r\n        string[] memory _description,\r\n        string[] memory _mHash,\r\n        string[] memory _qHash\r\n    ) internal {\r\n        for (uint256 i = 0; i < _name.length; i++) {\r\n            Module memory newModule = Module({\r\n                name: _name[i],\r\n                description: _description[i],\r\n                materialsHash: _mHash[i],\r\n                questionsHash: _qHash[i]\r\n            });\r\n            modulesToPush.push(newModule);\r\n        }\r\n        moduleVersions[index] = modulesToPush;\r\n        delete (modulesToPush);\r\n        index++;\r\n    }\r\n\r\n    function returnModules(uint256 _version)\r\n        external\r\n        view\r\n        returns (\r\n            string[] memory _name,\r\n            string[] memory _desc,\r\n            string[] memory _materials,\r\n            string[] memory questions\r\n        )\r\n    {\r\n        Module[] memory modulesToReturn = moduleVersions[_version];\r\n\r\n        uint256 length = modulesToReturn.length;\r\n\r\n        string[] memory names = new string[](length);\r\n        string[] memory descriptions = new string[](length);\r\n        string[] memory mHashes = new string[](length);\r\n        string[] memory qHashes = new string[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            Module memory module = modulesToReturn[i];\r\n            names[i] = module.name;\r\n            descriptions[i] = module.description;\r\n            mHashes[i] = module.materialsHash;\r\n            qHashes[i] = module.questionsHash;\r\n        }\r\n        return (names, descriptions, mHashes, qHashes);\r\n    }\r\n\r\n    function createRequest(\r\n        string memory _nameReq,\r\n        string memory _descriptionReq,\r\n        uint256 _tokens,\r\n        string[] memory _moduleNames,\r\n        string[] memory _moduleDescriptions,\r\n        string[] memory _materialsHash,\r\n        string[] memory _questionsHash,\r\n        uint256 _baseVersion\r\n    ) external {\r\n        Request memory newRequest = Request({\r\n            name: _nameReq,\r\n            description: _descriptionReq,\r\n            author: msg.sender,\r\n            confirmed: false,\r\n            tokens: _tokens,\r\n            approvers: 0,\r\n            baseVersion: _baseVersion\r\n        });\r\n\r\n        listOfRequests.push(newRequest);\r\n\r\n        for (uint256 i = 0; i < _moduleNames.length; i++) {\r\n            Module memory newModule = Module({\r\n                name: _moduleNames[i],\r\n                description: _moduleDescriptions[i],\r\n                materialsHash: _materialsHash[i],\r\n                questionsHash: _questionsHash[i]\r\n            });\r\n            modulesToPush.push(newModule);\r\n        }\r\n        requestModules[requestIndex] = modulesToPush;\r\n        delete (modulesToPush);\r\n        requestIndex++;\r\n    }\r\n\r\n    function voteRequest(uint256 ID) external {\r\n        // require(maintainerVotes[ID][msg.sender] != true);\r\n        maintainerVotes[ID][msg.sender] = true;\r\n        Request storage request = listOfRequests[ID];\r\n        request.approvers++;\r\n        if (request.approvers >= numOfMaintainers) {\r\n            approveRequest(ID);\r\n        }\r\n    }\r\n\r\n    function approveRequest(uint256 ID) internal {\r\n        //Approves a request at index ID in list of requests array,\r\n        //changes the approver address and confirmed boolean,\r\n        //pushes all the new modules stored in request module mapping, into current modules array mapping.\r\n\r\n        Request storage request = listOfRequests[ID];\r\n        require(request.confirmed != true);\r\n        request.confirmed = true;\r\n\r\n        Module[] memory modules = requestModules[ID];\r\n\r\n        uint256 length = modules.length;\r\n\r\n        string[] memory names = new string[](length);\r\n        string[] memory descriptions = new string[](length);\r\n        string[] memory materialHashes = new string[](length);\r\n        string[] memory questionHashes = new string[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            Module memory module = modules[i];\r\n            names[i] = module.name;\r\n            descriptions[i] = module.description;\r\n            materialHashes[i] = module.materialsHash;\r\n            questionHashes[i] = module.questionsHash;\r\n        }\r\n\r\n        pushModules(names, descriptions, materialHashes, questionHashes);\r\n        tokenHolders[tokenHoldersCounter] = request.author;\r\n        tokenHoldersCounter++;\r\n    }\r\n\r\n    function returnRequestModules(uint256 ID)\r\n        external\r\n        view\r\n        returns (\r\n            string[] memory _moduleNames,\r\n            string[] memory _moduleDescs,\r\n            string[] memory _moduleMaterials,\r\n            string[] memory _modulesQuestions\r\n        )\r\n    {\r\n        Module[] memory modulesToReturn = requestModules[ID];\r\n\r\n        uint256 length = modulesToReturn.length;\r\n\r\n        string[] memory names = new string[](length);\r\n        string[] memory descriptions = new string[](length);\r\n        string[] memory materials = new string[](length);\r\n        string[] memory questions = new string[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            Module memory module = modulesToReturn[i];\r\n            names[i] = module.name;\r\n            descriptions[i] = module.description;\r\n            materials[i] = module.materialsHash;\r\n            questions[i] = module.questionsHash;\r\n        }\r\n        return (names, descriptions, materials, questions);\r\n    }\r\n\r\n    function returnRequestSummary(uint256 ID)\r\n        external\r\n        view\r\n        returns (\r\n            string[2] memory,\r\n            address,\r\n            bool,\r\n            uint256[3] memory\r\n        )\r\n    {\r\n        Request memory request = listOfRequests[ID];\r\n        string[2] memory nameDesc = [request.name, request.description];\r\n        uint256[3] memory tokensApprovers = [\r\n            request.tokens,\r\n            request.approvers,\r\n            request.baseVersion\r\n        ];\r\n\r\n        return (nameDesc, request.author, request.confirmed, tokensApprovers);\r\n    }\r\n\r\n    function enroll(address _student) external payable {\r\n        require(msg.sender == momAddress);\r\n        enrolled[_student] = true;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}